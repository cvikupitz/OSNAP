Additional Notes Following Lecture:
Test scores were good for the midterm. Having a good mental model of the file system and git are important since those impact the other assignment work.


This week has been miserable for many of us with tests, homework, and other obligations. Hopefully next week will be a better week. Thank you for still taking the time to look at the assignment requirements earlier for this class, even if you've been unable to work on this week's project. I've addad a FAQ section to the assignment to capture questions and answers that are being captured.


I've heard people asking about GET vs POST, I spent a little bit of time looking into the RFC that defines the protocol. The major differences I saw were in the proxy behavior and length limitations that fall out of the history of the web. 

I think the interesting thing to note is that limitation on how much data comes through GET requests is not from the protocol specification. In the history of the web (as a system) a sensible design decision was made to limit the size of the buffer used when parsing URIs, which has become a constraint on future systems that interoperate with the web.


I fell a little flat trying to get some discussion on various titles that show up in technology. I place development on a spectrum that has to do with the scope of the toolbox and problem. Programmer -> Developer -> Software Engineer -> Architect

We identified the following software engineer traits:
- More about process than programmers or developers
- More about going from an abstract task to a solution
- More wholistic in the view of the program and the process it supports
- Holds to a process and thinks through all the steps
- Works from design through specification and implementation
which is a good list and I think the right kinds of ideas.

The code we write fits in a context, that can be massive. What we are concerned about at different levels differs however our approach is the same. Take the problem and define some set of modular chunks. Subdivide the chunks into smaller modular chunks. Once the chunks are small enough, implement.

For a programmer, these chunks may be function points. For a developer, these chunks may be modules. For an engineer these chunks are likely systems. For an architect these chunks are systems of systems. It's also good to remember that not all problems solve with a technical solution, good solutions may involve computers and humans in the process.


We also worked on design and implementation of a calculator application. The questions for specification clarification were excellent. We identified some different technologies to apply to the problem, our technology toolkit.

We had a problem needing data to be stored between program invocations. We offered up the database, textfile, and json file as solutions. I hadn't considered json before lecture, which ended up being a strategy with some really nice behavior (e.g. json matches the behavior of the Flask session object well and using a simple text file we wouldn't have been able to get multiple accumulators working in time).

We also talked briefly talked about language. Bash was offered and I countered with Python. I probably should've stayed on this decision a little longer in lecture. Bash is a sensible choice, we're building an application to run on the shell and bash is the shell. The risk using bash is that none of us know it very well. We can take advantage of the well defined interface between the shell and applications to change technologies (i.e. we can swap bash, that we don't know well, for python, which we know much better).

Implementing the state tracing is a bit of trouble/challenge... Thankfully Flask handles all of that challenge for us in our web application. Flask will automatically read the correct session data for the requesting client before executing a route. Flask will also automatically write out the current session data when finishing execution of a route. All you need to do is import the session and store the values you want in it.

In setting up for the calc exercise, I used a few shell commands you're likely unfamiliar with...

Sometimes it is useful to know the number of characters, words, and lines in a file. The wc command can do this. To get the number of lines in a file named app.py the following command could be used:
wc -l app.py

If no file name is give, wc reads from stdin... counting the number of lines from a directory listing can be done with a pipe '|', which connects the stdout of the command on the left to the stdin of the command on the right.
ls -l | wc -l

PATH is the environmental variable that lists the directories to search for applications in. This can be updated by setting the value.
PATH=.:$PATH

To get the result of a command as a string in another command, the '`' can be used. For example, to get approximately the number of entries in the directory into the calculator application:
calc + `ls -l | wc -l`


Here's the code from our implementation:
#! /usr/bin/python3

import sys
import json
import psycopg2

def main():

    # Read state file and set state
    with open('session') as f:
        state_data = json.loads(f.read())
    last_acc = state_data['last_acc']
    state = state_data[last_acc]
    
    if len(sys.argv) < 3:
        print("Usage: %s <op> <value>"%sys.argv[0])
        return

    op = sys.argv[1]
    if not op in ('+','-','x','/','=','s'):
        print("Invalid op: %s"%op)
        return

    val = sys.argv[2]
    try:
        val = float(val)
    except:
        print("Invalid number: %s"%val)
        return

    if op=='+':
        state += val
    if op=='-':
        state -= val
    if op=='x':
        state *= val
    if op=='/':
        state /= val
    if op == '=':
        print(state)
    if op == 's':
        last_acc = int(val)
        if last_acc in state_data:
            state = state_data[last_acc]
        else:
            state = 0
        state_data['last_acc'] = last_acc

    # Update state file
    state_data[last_acc] = state
    print("state: %s"%state_data)
    with open('session','w') as f:
        f.write(json.dumps(state_data))


if __name__=='__main__':
    main()
