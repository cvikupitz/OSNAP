Additional Notes Following Lecture:
My apologies for the level of disorganization in the presentation today... I'm still grappling with the large number of ideas that need to be bootstrapped for the project, doth the data modeling discussion and the management discussion suffered today. Hopefully this does an ok job capturing what I went over in class and few things I should've included but dropped.


Some high level ideas on relational databases...
Relational databases are made of a bunch of tables. Each table has some number of rows sharing the same columns (like a data in a spreadsheet).
Data in separate tables can be joined using columns that have the same value in multiple tables. The data types of a table's columns are statically defined when the table is created.

Assets::
asset_pk | asset_tag | product_fk
       1 | asset 1   | 14
       2 | asset 2   | 14
       5 | asset 3   | 27
       
Products::
product_pk | description
        14 | water bottle
        27 | note pad

We can tell that the record/row in the assets table with asset_pk 1 is a water bottle by joining the data in the two tables. 

In SQL, a select statement to do this might look like:
SELECT *
FROM assets a
JOIN products p ON a.product_fk=p.product_pk
WHERE asset_pk=1;

The select statement starts with the keyword 'SELECT' and ends with the ';'. Aliases are used in the query to uniquely identify the assets table and products table used for the join. The keyword 'ON' indicates the test to use when joining columns. The keyword 'WHERE' indicates the beginning of the list of filter conditions, in this case looking for only the entries where asset_pk is the value 1.

Rows are added to tables using 'INSERT'. Existing rows in tables are changed using 'UPDATE'. Rows can be removed from a table using 'DELETE'. To make a new table, 'CREATE TABLE' statements are used.

A primary key is a value that can uniquely identify a row within a table. No two rows in a table may have the same primary key. In Postgres I generally use the serial datatype for the primary key column and have Postgres set the value for each record at the time the record is inserted, guaranteeing that no two rows share the same value. Since the primary keys are just incremental numbers, the keys have no semantic meaning in the context of the record.

There is debate in database design communities about using semantically meaningful primary keys for rows in a table. An example of a semantically meaningful key might be using a social security number (SSN) as the primary key for people in an HR database; the key is also data for the thing the record refers to. I am against semantically meaningful primary keys. As requirements change, there is a high likelyhood that something formerly unique about the data will become non-unique. For example, using SSN for an HR database seems like a good plan until two people are hired with the same SSN (turns out SSNs are not guaranteed to be unique).

A lot of resources exist online for learning about SQL and relational databases. Hopefully this is enough to get you going this week.


Some tactical information on getting connected to Postgres...
From assignment 1, everyone should be able to build, install, and start a copy of the Postgres database server. I will refer to the install prefix you used as $PREFIX in the following notes.

To start the database server, some initial files are needed. 'initdb' is the command to setup these files. This only needs to be done once before starting the database server. The following example command initializes the files in $HOME/data:
$PREFIX/bin/initdb -D $HOME/data

After the initial files have been generated you can use pg_ctl to start the postgres server in the background. I don't use pg_ctl myself... though I can probably help you if you use pg_ctl and run into trouble. I start the server in one terminal window/shell instance and then do my work in a separate shell instance. To start the Postgres server after creating the initial files in $HOME/data:
$PREFIX/bin/postmaster -D $HOME/data
Some diagnostic data will be displayed and then the server will be up and running.

Once the server is running, you will want to create a database to hold your tables. 'createdb' is the command to build a new database within the database server. Like 'initdb' this command only needs to be run once when you first build the database. To build a database named 'lost', you could use the following command:
$PREFIX/bin/createdb lost

To connect to the database 'lost' and run interactive commands you will use psql. The Postgres server must be running before you try to connect interactively. The command would look like:
$PREFIX/bin/psql lost